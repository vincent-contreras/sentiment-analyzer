/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** JavaScript-compatible bootstrap node configuration */
export interface JsBootstrapNode {
  /** Peer ID (base58 encoded) */
  peerId: string
  /** Multiaddr string (e.g., "/ip4/127.0.0.1/tcp/9000") */
  multiaddr: string
}
/** JavaScript-compatible relay node configuration */
export interface JsRelayNodeConfig {
  /** Peer ID (base58 encoded) */
  peerId: string
  /** Multiaddr string */
  multiaddr: string
}
/**
 * JavaScript-compatible SelaClient configuration
 *
 * All fields are optional, allowing partial configuration.
 * Default values will be used for unspecified fields.
 */
export interface JsSelaClientConfig {
  /** Bootstrap nodes for DHT discovery */
  bootstrapNodes?: Array<JsBootstrapNode>
  /** Relay nodes for NAT traversal */
  relayNodes?: Array<JsRelayNodeConfig>
  /** API key for authentication (sk_live_xxx or sk_test_xxx) */
  apiKey?: string
  /** API Server URL for Session Token exchange (required when api_key is set) */
  apiServerUrl?: string
  /** Connection timeout in milliseconds (default: 30000) */
  connectionTimeoutMs?: number
  /** Request timeout in milliseconds (default: 60000) */
  requestTimeoutMs?: number
  /** Enable automatic relay discovery (default: true) */
  autoDiscoverRelays?: boolean
  /** Minimum agent reputation score (0.0 - 1.0, default: 0.3) */
  minReputationScore?: number
}
/**
 * JS-friendly error wrapper with structured info
 *
 * Provides a structured error object that can be inspected in JavaScript
 * with error code, message, and optional details.
 */
export interface JsSelaError {
  /** Error code (e.g., "NOT_STARTED", "CONNECTION_TIMEOUT") */
  code: string
  /** Human-readable error message */
  message: string
  /** Optional additional details */
  details?: string
  /** Whether this error is retryable */
  isRetryable: boolean
  /** Retry after milliseconds (for rate limiting) */
  retryAfterMs?: number
}
/**
 * JS-compatible event structure
 *
 * This struct is passed to JavaScript event handlers.
 * All optional fields allow flexibility across different event types.
 */
export interface JsClientEvent {
  /** Event type: "connected", "disconnected", "error", etc. */
  kind: string
  /** Peer ID if applicable */
  peerId?: string
  /** Single multiaddr (for Connected events) */
  multiaddr?: string
  /** Multiple multiaddrs (for AgentDiscovered events) */
  multiaddrs?: Array<string>
  /** Capabilities (for AgentDiscovered events) */
  capabilities?: Array<string>
  /** Human-readable message or error details */
  message?: string
  /** Error type (for Error events) */
  errorType?: string
  /** Whether the error is recoverable (for Error events) */
  recoverable?: boolean
  /** Peer count (for Bootstrapped events) */
  peerCount?: number
  /** Session ID (for Session events) */
  sessionId?: string
  /** Retry information - current attempt */
  attempt?: number
  /** Retry information - max attempts */
  maxAttempts?: number
  /** Retry delay in milliseconds */
  delayMs?: number
  /** Retry after milliseconds (for RateLimited events) */
  retryAfterMs?: number
  /** Request type (for Retrying events) */
  requestType?: string
  /** Event timestamp in milliseconds since Unix epoch */
  timestamp: number
}
/** JavaScript-compatible discovered agent information */
export interface JsDiscoveredAgent {
  /** Agent's Peer ID as base58 string */
  peerId: string
  /** Agent's multiaddrs as string array */
  multiaddrs: Array<string>
  /** Agent capabilities (e.g., ["web", "browse"]) */
  capabilities: Array<string>
  /** Cached reputation record (if available) */
  reputation?: JsReputationRecord
}
/** JavaScript-compatible reputation record */
export interface JsReputationRecord {
  /** Peer ID this reputation belongs to */
  peerId: string
  /** Aggregate reputation score (0.0 - 1.0) */
  score: number
  /** Total number of successful tasks (as f64 for JS compatibility) */
  successCount: number
  /** Total number of failed tasks */
  failureCount: number
  /** Total number of timeout events */
  timeoutCount: number
  /** Average response time in milliseconds */
  avgResponseTimeMs: number
  /** Last updated timestamp (Unix seconds as f64) */
  updatedAt: number
  /** Number of unique raters */
  raterCount: number
  /** Version for conflict resolution */
  version: number
}
/** JavaScript-compatible semantic response */
export interface JsSemanticResponse {
  /** Correlation ID matching the request */
  requestId: string
  /** Session ID for follow-up operations */
  sessionId: string
  /** The parsed semantic page content */
  page: JsSemanticPage
  /** Result of the action (if any) */
  actionResult: JsActionResult
  /** Optional message */
  message?: string
  /** Raw HTML content (only when include_html=true in request) */
  rawHtml?: string
}
/** JavaScript-compatible semantic page */
export interface JsSemanticPage {
  /** Current page URL */
  url: string
  /** Page type identifier (e.g., "x.com::search", "linkedin.com::feed") */
  pageType: string
  /** Page metadata */
  metadata: JsPageMetadata
  /** Extracted content items (as JSON string for complex nested data) */
  content: string
  /** Page-level available actions (as JSON string) */
  availableActions: string
  /** Schema version used for parsing */
  schemaVersion: number
  /** Extraction timestamp */
  extractedAt: number
}
/** JavaScript-compatible page metadata */
export interface JsPageMetadata {
  /** Page title */
  title?: string
  /** Page description */
  description?: string
  /** Page author/owner */
  author?: string
  /** Canonical URL */
  canonicalUrl?: string
}
/** JavaScript-compatible action result */
export interface JsActionResult {
  /** Status: "success", "failed", "already_performed", "skipped", "pending_approval" */
  status: string
  /** Error message (for failed status) */
  error?: string
}
/** JavaScript-compatible browser response */
export interface JsBrowserResponse {
  /**
   * Response type: "session_created", "browsed", "screenshot", "html",
   * "session_closed", "login_status", "login_required", "error"
   */
  type: string
  /** Session ID (present in most response types) */
  sessionId?: string
  /** Session info (for session_created) */
  info?: JsSessionInfo
  /** URL (for browsed) */
  url?: string
  /** Base64 image data (for screenshot) */
  imageData?: string
  /** Image format (for screenshot) */
  format?: string
  /** HTML content (for html) */
  html?: string
  /** Service name (for login_status, login_required) */
  service?: string
  /** Whether logged in (for login_status) */
  loggedIn?: boolean
  /** Login URL (for login_required) */
  loginUrl?: string
  /** Message (for login_status, login_required, error) */
  message?: string
  /** Error code (for error) */
  code?: string
}
/** JavaScript-compatible session info */
export interface JsSessionInfo {
  /** Session ID */
  sessionId: string
  /** Browser type (chrome, firefox, etc.) */
  browserType: string
  /** Browser version */
  browserVersion?: string
  /** User agent */
  userAgent: string
  /** Creation timestamp (Unix epoch seconds as f64) */
  createdAt: number
}
/** JavaScript-compatible browse options */
export interface JsBrowseOptions {
  /** Session ID for an existing session (optional, creates new if not provided) */
  sessionId?: string
  /** API key to forward to the agent (optional, uses config if not provided) */
  apiKey?: string
  /** Request timeout in milliseconds */
  timeoutMs?: number
  /** Parse-only mode: skip LLM action planning, only extract semantic content */
  parseOnly?: boolean
  /** Whether to include raw HTML in response */
  includeHtml?: boolean
  /** Number of items to collect (for infinite scroll/pagination) */
  count?: number
  /**
   * Filters to apply before content extraction (e.g., { "sort": "newest", "channel": "video" })
   * Keys are filter names from the schema, values are option keys
   */
  filters?: Record<string, string>
  /** Target specific agent by peer ID (for testing/POC) */
  agentId?: string
  /** Query hint for semantic extraction */
  query?: string
}
/** JavaScript-compatible discovery options */
export interface JsDiscoveryOptions {
  /** Maximum number of agents to discover */
  maxAgents?: number
  /** Minimum reputation score filter */
  minReputation?: number
  /** Discovery timeout in milliseconds */
  timeoutMs?: number
}
/** JavaScript-compatible connection options */
export interface JsConnectionOptions {
  /** Connection timeout in milliseconds */
  timeoutMs?: number
}
/** JavaScript-compatible screenshot options */
export interface JsScreenshotOptions {
  /** Image format ("png" or "jpeg") */
  format?: string
  /** Whether to capture full page (not just viewport) */
  fullPage?: boolean
}
/** JavaScript-compatible connected agent information */
export interface JsConnectedAgent {
  /** Agent's Peer ID as base58 string */
  peerId: string
  /** Agent's multiaddrs as string array */
  multiaddrs: Array<string>
  /** Average response time in milliseconds */
  avgResponseTimeMs: number
  /** Cached reputation score (if available) */
  reputationScore?: number
}
/** JavaScript-compatible relay node information */
export interface JsRelayNode {
  /** Relay's Peer ID as base58 string */
  peerId: string
  /** Relay's multiaddr */
  multiaddr: string
  /** Whether currently connected to this relay */
  isConnected: boolean
}
/**
 * JavaScript-compatible task outcome
 *
 * Note: napi(string_enum) automatically derives Clone, so we don't derive it manually
 */
export const enum JsTaskOutcome {
  /** Task completed successfully */
  Success = 'Success',
  /** Task failed due to peer error */
  Failed = 'Failed',
  /** Task timed out */
  Timeout = 'Timeout',
  /** Task was cancelled (no reputation impact) */
  Cancelled = 'Cancelled'
}
/**
 * Get the SDK version
 *
 * @returns The SDK version string
 */
export declare function version(): string
/**
 * Get list of valid event types that can be subscribed to
 *
 * Valid event types:
 * - "connected": Agent connection established
 * - "disconnected": Agent disconnected
 * - "reconnecting": Reconnection attempt in progress
 * - "agent_discovered": New agent found via DHT
 * - "agent_lost": Agent no longer available
 * - "rate_limited": Request rate limited
 * - "retrying": Request being retried
 * - "error": Error occurred
 * - "bootstrapped": Bootstrap complete
 * - "session_created": Browser session created
 * - "session_closed": Browser session closed
 *
 * @returns Array of valid event type strings
 */
export declare function validEventTypes(): Array<string>
/**
 * JavaScript-compatible SelaClient wrapper
 *
 * This class provides a Node.js native binding for the Sela Network client.
 * It wraps the Rust SelaClient with napi-rs for async/Promise support.
 *
 * # Example (JavaScript)
 * ```javascript
 * const { SelaClient } = require('@selanet/sdk');
 *
 * const client = await SelaClient.create({
 *   bootstrapNodes: [{ peerId: '12D3KooW...', multiaddr: '/ip4/...' }],
 *   apiKey: 'sk_live_xxx'
 * });
 *
 * // Register event handlers
 * client.on('connected', (event) => console.log('Connected:', event));
 * client.on('error', (event) => console.error('Error:', event));
 *
 * await client.start();
 * const agents = await client.discoverAgents('web');
 * const response = await client.browse('https://example.com');
 *
 * client.off('connected');
 * await client.stop();
 * ```
 */
export declare class JsSelaClient {
  /**
   * Create a new SelaClient with optional configuration
   *
   * @param config - Optional configuration object
   * @returns Promise<SelaClient>
   */
  static create(config?: JsSelaClientConfig | undefined | null): Promise<JsSelaClient>
  /**
   * Create a new SelaClient from environment variables
   *
   * Environment variables:
   * - BOOTSTRAP_PEERS: Comma-separated list (format: peer_id@multiaddr)
   * - SELA_API_KEY: API key
   * - SELA_CONNECTION_TIMEOUT: Connection timeout in seconds
   * - SELA_REQUEST_TIMEOUT: Request timeout in seconds
   *
   * @returns Promise<SelaClient>
   */
  static fromEnv(): Promise<JsSelaClient>
  /**
   * Create a new SelaClient with API key only (uses all defaults)
   *
   * This is the simplest way to create a client for POC/demo usage.
   * - Bootstrap nodes: Resolved from /dnsaddr/bootstrap.selanet.ai
   * - Relay discovery: Automatic
   * - All other settings: Default values
   *
   * @param apiKey - API key for authentication (sk_live_xxx or sk_test_xxx)
   * @returns Promise<SelaClient>
   *
   * @example
   * ```javascript
   * const client = await SelaClient.withApiKey('sk_live_xxx');
   * await client.start();
   * const agents = await client.discoverAgents('web');
   * ```
   */
  static withApiKey(apiKey: string): Promise<JsSelaClient>
  /**
   * Get the local peer ID
   *
   * @returns The local peer ID as a base58 string
   */
  get localPeerId(): Promise<string>
  /**
   * Get the current client state
   *
   * @returns One of: "created", "starting", "running", "stopping", "stopped"
   */
  get state(): Promise<string>
  /**
   * Check if connected to an agent
   *
   * @returns true if a healthy primary agent is connected
   */
  get isConnected(): Promise<boolean>
  /**
   * Get the current session ID
   *
   * Returns the current browser session ID if one exists.
   * The session ID is automatically set when calling browse() or createSession().
   *
   * @returns The session ID string or null if no session exists
   */
  get sessionId(): Promise<string | null>
  /**
   * Set the API key for authentication
   *
   * This overrides the API key from the initial configuration.
   * The new API key will be used for all subsequent requests.
   *
   * @param apiKey - The API key string (e.g., "sk_live_xxx" or "sk_test_xxx")
   * @returns Promise<void>
   */
  setApiKey(apiKey: string): Promise<void>
  /**
   * Get a valid session token from the TokenManager
   *
   * Returns cached token if valid, otherwise fetches a new one from API Server.
   * Requires api_key and api_server_url to be configured.
   *
   * @returns Session token (JWT) or null if not configured
   * @throws Error if token fetch fails
   */
  getSessionToken(): Promise<string | null>
  /**
   * Get the currently connected agent
   *
   * @returns ConnectedAgent or null if not connected
   */
  connectedAgent(): Promise<JsConnectedAgent | null>
  /**
   * Get the current relay node
   *
   * @returns RelayNode or null if not using relay
   */
  currentRelay(): Promise<JsRelayNode | null>
  /**
   * Get all known relay nodes
   *
   * @returns Array of RelayNode
   */
  getRelays(): Promise<Array<JsRelayNode>>
  /**
   * Start the client
   *
   * Connects to bootstrap nodes and initializes the P2P network.
   * Also starts the event loop for forwarding events to JS handlers.
   *
   * @returns Promise<void>
   */
  start(): Promise<void>
  /**
   * Stop the client (immediate)
   *
   * @returns Promise<void>
   */
  stop(): Promise<void>
  /**
   * Graceful shutdown with optional timeout
   *
   * @param timeoutMs - Optional timeout in milliseconds (default: 30000)
   * @returns Promise<void>
   */
  shutdown(timeoutMs?: number | undefined | null): Promise<void>
  /**
   * Reconnect to the last connected agent
   *
   * @returns Promise<void>
   * @throws Error if no previous connection exists or client not started
   */
  reconnect(): Promise<void>
  /**
   * Register an event listener
   *
   * @param event - Event type to listen for. Valid types:
   *   - "connected": Agent connection established
   *   - "disconnected": Agent disconnected
   *   - "reconnecting": Reconnection attempt in progress
   *   - "agent_discovered": New agent found via DHT
   *   - "agent_lost": Agent no longer available
   *   - "rate_limited": Request rate limited
   *   - "retrying": Request being retried
   *   - "error": Error occurred
   *   - "bootstrapped": Bootstrap complete
   *   - "session_created": Browser session created
   *   - "session_closed": Browser session closed
   * @param callback - Function to call when event occurs
   *
   * @example
   * ```javascript
   * client.on('connected', (event) => {
   *   console.log('Connected to:', event.peerId);
   *   console.log('At address:', event.multiaddr);
   * });
   *
   * client.on('error', (event) => {
   *   console.error('Error:', event.message);
   *   if (event.recoverable) {
   *     console.log('This error is recoverable');
   *   }
   * });
   * ```
   */
  on(event: string, callback: (...args: any[]) => any): void
  /**
   * Remove all event listeners for a specific event type
   *
   * @param event - Event type to remove listeners for
   *
   * @example
   * ```javascript
   * client.on('connected', handler1);
   * client.on('connected', handler2);
   * client.off('connected'); // Removes both handlers
   * ```
   */
  off(event: string): void
  /**
   * Discover agents with optional capability filter
   *
   * @param capability - Optional capability filter (e.g., "web", "browse")
   * @param options - Optional discovery options
   * @returns Promise<DiscoveredAgent[]>
   */
  discoverAgents(capability?: string | undefined | null, options?: JsDiscoveryOptions | undefined | null): Promise<Array<JsDiscoveredAgent>>
  /**
   * Connect to a specific agent
   *
   * @param peerId - The agent's peer ID
   * @param multiaddr - The agent's multiaddr
   * @param options - Optional connection options
   *   - timeout_ms: Connection timeout in milliseconds
   * @returns Promise<void>
   */
  connectToAgent(peerId: string, multiaddr: string, options?: JsConnectionOptions | undefined | null): Promise<void>
  /**
   * Connect to the first available agent from a list (parallel race)
   *
   * This method implements a parallel racing strategy (like Promise.any):
   * 1. Start dialing ALL agents simultaneously
   * 2. First successful connection wins
   * 3. Set the winner as the primary agent
   *
   * This ensures connection to the "currently fastest" node,
   * providing natural load balancing across the distributed network.
   *
   * @param agents - Array of discovered agents to try
   * @param timeoutMs - Optional timeout in milliseconds (default: 30000)
   * @returns Promise<DiscoveredAgent> - The successfully connected agent
   */
  connectToFirstAvailable(agents: Array<JsDiscoveredAgent>, timeoutMs?: number | undefined | null): Promise<JsDiscoveredAgent>
  /**
   * Connect to a specific agent by PeerId only
   *
   * Discovers the agent's multiaddr via DHT and connects.
   * This is useful when you know the agent's PeerId but not its address.
   *
   * @param peerId - The agent's PeerId string (e.g., "12D3KooW...")
   * @returns Promise<ConnectedAgent>
   *
   * @example
   * ```javascript
   * const agent = await client.connectToPeer('12D3KooWxxx');
   * console.log('Connected to:', agent.peerId);
   * ```
   */
  connectToPeer(peerId: string): Promise<JsConnectedAgent>
  /**
   * Browse a URL and get semantic response
   *
   * @param url - The URL to browse
   * @param options - Optional browse options
   * @returns Promise<SemanticResponse>
   */
  browse(url: string, options?: JsBrowseOptions | undefined | null): Promise<JsSemanticResponse>
  /**
   * Create a new browser session
   *
   * @param userAgent - Optional custom user agent
   * @returns Promise<BrowserResponse>
   */
  createSession(userAgent?: string | undefined | null): Promise<JsBrowserResponse>
  /**
   * Take a screenshot of the current page
   *
   * @param sessionId - The session ID
   * @param options - Optional screenshot options (format, fullPage)
   * @returns Promise<BrowserResponse>
   */
  screenshot(sessionId: string, options?: JsScreenshotOptions | undefined | null): Promise<JsBrowserResponse>
  /**
   * Get the HTML content of the current page
   *
   * @param sessionId - The session ID
   * @returns Promise<BrowserResponse>
   */
  getHtml(sessionId: string): Promise<JsBrowserResponse>
  /**
   * Search using semantic protocol
   *
   * @param query - The search query
   * @param targetUrl - Optional target URL to search within
   * @returns Promise<SemanticResponse>
   */
  search(query: string, targetUrl?: string | undefined | null): Promise<JsSemanticResponse>
  /**
   * Discover relay nodes
   *
   * @param maxRelays - Optional maximum number of relays to discover
   * @returns Promise<RelayNode[]>
   */
  discoverRelays(maxRelays?: number | undefined | null): Promise<Array<JsRelayNode>>
  /**
   * Get reputation for a peer
   *
   * @param peerId - The peer ID to query
   * @returns Promise<ReputationRecord | null>
   */
  getReputation(peerId: string): Promise<JsReputationRecord | null>
  /**
   * Report task outcome for reputation tracking
   *
   * @param peerId - The peer ID being rated
   * @param outcome - Task outcome (Success, Failed, Timeout, Cancelled)
   * @param responseTimeMs - Optional response time in milliseconds
   * @param taskType - Optional task type (e.g., "browse", "semantic")
   * @returns Promise<void>
   */
  reportOutcome(peerId: string, outcome: JsTaskOutcome, responseTimeMs?: number | undefined | null, taskType?: string | undefined | null): Promise<void>
  /**
   * Get reputation for multiple peers (batch query)
   *
   * Queries reputation for all provided peer IDs in parallel.
   * Invalid peer IDs and failed queries are skipped (partial success).
   *
   * @param peerIds - Array of peer IDs to query
   * @returns Promise<Map<string, ReputationRecord | null>>
   */
  getReputations(peerIds: Array<string>): Promise<Record<string, JsReputationRecord | undefined | null>>
  /**
   * Filter agents by reputation score
   *
   * Returns only agents with reputation score >= minScore.
   * Agents without reputation records are included (benefit of doubt for new peers).
   *
   * @param agents - Array of discovered agents
   * @param minScore - Minimum reputation score (0.0 - 1.0, default: 0.3)
   * @returns Promise<DiscoveredAgent[]>
   */
  filterAgentsByReputation(agents: Array<JsDiscoveredAgent>, minScore?: number | undefined | null): Promise<Array<JsDiscoveredAgent>>
  /**
   * Sort agents by reputation score (highest first)
   *
   * Agents without reputation are placed in the middle (treated as 0.5 score).
   *
   * @param agents - Array of discovered agents
   * @returns Promise<DiscoveredAgent[]>
   */
  sortAgentsByReputation(agents: Array<JsDiscoveredAgent>): Promise<Array<JsDiscoveredAgent>>
  /**
   * Clear reputation cache
   *
   * Forces fresh queries to DHT on next reputation request.
   * Useful when you suspect cached data is stale.
   *
   * @returns Promise<void>
   */
  clearReputationCache(): Promise<void>
  /**
   * Check if the connected agent is reliable
   *
   * Returns true if the primary agent has a reputation score above the minimum threshold.
   * Agents without reputation records are considered reliable (new agent policy).
   *
   * @returns Promise<boolean>
   */
  isConnectedAgentReliable(): Promise<boolean>
  /**
   * Create a JsSelaError from an error message
   *
   * Useful for getting structured error information including error codes
   * and retry hints.
   *
   * @param message - Error message string
   * @returns Structured error information
   */
  static createError(message: string): JsSelaError
}
